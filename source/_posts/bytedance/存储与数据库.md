---
title: 存储与数据库
toc: true
date: 2025-02-13 00:00:00
tags: 数据库
categories: bytedance
---

​点击阅读更多查看文章内容<!--more-->


# RDBMS

## 经典案例

### 事务ACID

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932183.png" alt="image-20250121211555381" style="zoom: 67%;" />

原子性：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932185.png" alt="image-20250121211659360" style="zoom: 50%;" />

一致性：（强调状态的合法性）

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932186.png" alt="image-20250121211807139" style="zoom: 50%;" />

隔离性：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932187.png" alt="image-20250121211855885" style="zoom:50%;" />

持久性：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932188.png" alt="image-20250121211935949" style="zoom:67%;" />

### 高并发

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932189.png" alt="image-20250121212053461" style="zoom: 67%;" />

### 高可靠

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932190.png" alt="image-20250121212121191" style="zoom:67%;" />

## 数据模型

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932191.png" alt="image-20250121213116378" style="zoom:50%;" />

## 关键技术

一条SQL的一生

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932192.png" alt="image-20250121213636812" style="zoom:50%;" />

### SQL引擎

**Parser** 解析器

所有的代码在执行之前，都存在一个解析编译的过程， 差异点无非在于是静态解析编译还是动态的。SQL语言也类似，在SQL查询执行前的第一步就是查询解析

- 词法分析:将一条SQL语句对应的字符串分割为一个个token, 这些token可以简单分类。
- 语法分析:把词法分析的结果转为语法树。根据token序列匹配不同的语法规则，比如这里匹配的是update语法规则，类似的还有insert、 delete、 select. create、 drop等等语法规则。根据语法规则匹配SQL语句中的关键字，最终输出一个结构化的数据结构。
- 语义分析:对语法树中的信息进行合法性校验。

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932193.png" alt="image-20250121213926040" style="zoom:67%;" />

**Optimizer** 优化器

为什么需要优化器？

表连接有多种方式：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932194.png" alt="image-20250121214257287" style="zoom:67%;" />

基于规则的优化：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932196.png" alt="image-20250121214439720" style="zoom:67%;" />

基于代价的优化：（通常考虑整体的代价）

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932197.png" alt="image-20250121214543828" style="zoom:67%;" />

**Executor** 执行器

火山模型：逐层向下调用，逐层向上返回

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932198.png" alt="image-20250121214810134" style="zoom:67%;" />



向量化模型：每次计算一批数据

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932199.png" alt="image-20250121215026201" style="zoom:67%;" />

编译执行模型：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932200.png" alt="image-20250121215124335" style="zoom:67%;" />

### 存储引擎

**InnoDB**

内存中进行数据缓存

磁盘中存储：数据元信息（ibdata1）、用户真实数据（xxx.ibd）、日志信息（xxx.ibu、ib_logfileN）、临时表（xxx.ibt）

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932201.png" alt="image-20250121215442747" style="zoom:67%;" />

**Buffer Pool**

MySQL中每个chunk的大小一般为128M， 每个block对应一个page, 一个chunk 下面有8192个block。这样可以避免内存碎片化。

分成多个instance,可以有效避免并发冲突。

Page id % instance num得到它属于哪个instance

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932202.png" alt="image-20250121215908228" style="zoom:67%;" />

HashMap：page寻址

LRU：内存替换策略

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932203.png" alt="image-20250121220052398" style="zoom:67%;" />

**Page**

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932204.png" alt="image-20250121220348142" style="zoom:67%;" />

**B+ Tree：构建索引**

叶子节点通过双向链表连接

- 点查：从根到叶查到数据 
- 范围查询：根据叶子的链表继续遍历叶子节点查询

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932205.png" alt="image-20250121220444499" style="zoom: 67%;" />

### 事务引擎

**原子性**：如果事务执行失败需要回退，通过undo log记录数据回退的操作

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932206.png" alt="image-20250121220751639" style="zoom:67%;" />

**一致性**：主要在业务层实现

**隔离性**：通过加锁实现

​	读读：共享锁，可以同时读

​	写写：排他锁，一个人写另一个人就不能再写

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932207.png" alt="image-20250121221014015" style="zoom: 67%;" />

​	读写：读写互不阻塞，MVCC机制，为数据创建多个版本来支持多个事务同时读取和修改数据库。

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932208.png" alt="image-20250121221208103" style="zoom:67%;" />

**持久性**

随机IO：随机访问磁盘效率较低

写放大：数据的最小管理单元是页面16（KB），写数据可能只修改几个字节，但是要占用整个页面

WAL：修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中; 如果事务失败，WAL中的记录会被忽略，撤销修改; 如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。

​	优点：只记录增量变化，没有写放大；Append only,没有随机IO

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932209.png" alt="image-20250121221931305" style="zoom:67%;" />

## 企业实践

流量大、流量突增、稳定性

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932210.png" alt="image-20250121222739345" style="zoom:67%;" />

### 大流量

Sharding：将数据水平拆分，分给多个服务器存储

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932211.png" alt="image-20250121222911406" style="zoom:67%;" />

### 流量突增

扩容

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932212.png" alt="image-20250121223207364" style="zoom:67%;" />

代理连接池

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932213.png" alt="image-20250121223319343" style="zoom:67%;" />

### 稳定性&可靠性

3AZ高可用

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932214.png" alt="image-20250121223500165" style="zoom:67%;" />

HA管理

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932215.png" alt="image-20250121223558558" style="zoom:67%;" />

## 总结

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932216.png" alt="image-20250121223644387" style="zoom:67%;" />

# 对象存储

## 需求

短视频架构：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932218.png" alt="image-20250121225121026" style="zoom:67%;" />

存储需求：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932219.png" alt="image-20250121225139012" style="zoom:67%;" />

存储量：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932220.png" alt="image-20250121225225623" style="zoom:67%;" />

要求：

- 易用：好的存储能够解放业务，让业务专注于业务逻辑开发
- 海量：从前面分析，这个存储系统一定要能够存储如此大的海量
- 便宜：这么大的存储量，越便宜就越能省下宝贵的经费

## 为什么需要对象存储

存储系统的分类：

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932221.png" alt="image-20250121225432913" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932222.png" alt="image-20250121225735047" style="zoom:67%;" />

分布式数据库适合存储大量结构化数据，例如身份证号

### 分布式存储

包括分布式文件系统和对象存储

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932223.png" alt="image-20250121230008979" style="zoom:67%;" />

### 适用场景

静态不变

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932224.png" alt="image-20250121230407017" style="zoom:67%;" />

## 对象存储怎么使用

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932225.png" alt="image-20250122110326739" style="zoom:67%;" />

**Restful接口**

通过restful接口直接操作对象存储

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932226.png" alt="image-20250122110654247" style="zoom:67%;" />

**MultiUpload接口**

大文件上传

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932227.png" alt="image-20250122111214742" style="zoom:67%;" />

**ListPrefix接口**

分页列举

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932228.png" alt="image-20250122111453483" style="zoom:67%;" />

## 总结

<img src="https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/20250303123932229.png" alt="image-20250122114214308" style="zoom:67%;" />

