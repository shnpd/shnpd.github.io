---
title: 字典树（介绍+实现+例题）
toc: true
date: 2021-09-16 16:40:25
tags: 数据结构 c++
categories: 数据结构
---

​​点击阅读更多查看文章内容<!--more-->

## 字典树

## 介绍

字典树也叫前缀树、Trie树等
字典树是一颗非典型的多叉树模型
字典树的结点包含有一个长度为26的指针数组，分别对应26个字母，指向当前字母对应的下一个字母。
字典树充分利用了字符串的公共前缀
包含三个单词 "sea","sells","she" 的字典树如下所示：
![](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/69b390bac7802a12d92f940573e29c39_1740931359319.png)
[图片来源](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/)

## 代码实现
**定义**
```cpp
 struct Trie
    {
        vector<Trie *> children;
        string word;
        Trie() : children(26), word("") {}
    };
```
**插入**
                                 

```cpp
 void insert(Trie *root, string word)
    {
        Trie *node = root;
        for (char c : word)
        {
             c -= 'a';
            if (node->children[c] == nullptr)
                node->children[c] = new Trie();
            node = node->children[c];
        }
        node->word = word;
    }
```
**查找**

```cpp
 bool search(Trie *root, string word)
    {
        Trie *node = root;
        for (char c : word)
        {
            c -= 'a';
            if (node->letter[c] == nullptr)
                return false;
            node=node->letter[c];
        }
        if (node->word != "")
            return true;
        else
            return false;
    }
```

**前缀查找**

```cpp
  bool startsWith(Trie *root,string prefix)
    {
        Trie *node = root;
        for (char c : prefix)
        {
            c -= 'a';
            if (node->letter[c] == nullptr)
                return false;
            node=node->letter[c];
        }
        return true;
    }
```

## 例题
> [**LeetCode 208**](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
> Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

```cpp
class Trie
{
private:
    vector<Trie*> letter;
    bool isend = false;
public:
    Trie():letter(26), isend(false)
    {
    }
    void insert(string word)
    {
        Trie *node = this;
        for (char c : word)
        {
            c -= 'a';
            if (node->letter[c] == nullptr)
                node->letter[c] = new Trie();
            node = node->letter[c];
        }
        node->isend = true;
    }
    bool search(string word)
    {
        Trie *node = this;
        for (char c : word)
        {
            c -= 'a';
            if (node->letter[c] == nullptr)
                return false;
            node=node->letter[c];
        }
        if (node->isend)
            return true;
        else
            return false;
    }
    bool startsWith(string prefix)
    {
        Trie *node = this;
        for (char c : prefix)
        {
            c -= 'a';
            if (node->letter[c] == nullptr)
                return false;
            node=node->letter[c];
        }
        return true;
    }
};
```

> 
> [**LeetCode 212**](https://leetcode-cn.com/problems/word-search-ii)
> 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
**示例：**
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

```cpp
class Solution
{
public:
    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    vector<string> ret;
    struct Trie
    {
        vector<Trie *> children;
        string word;
        Trie() : children(26), word("") {}
    };
    void insert(Trie *root, string word)
    {
        Trie *node = root;
        for (char c : word)
        {
            int i = c - 'a';
            if (node->children[i] == nullptr)
                node->children[i] = new Trie();
            node = node->children[i];
        }
        node->word = word;
    }
    void dfs(int x, int y, Trie *node, vector<vector<char>> &board)
    {
        char c = board[x][y];
        if (node->children[c - 'a'] == nullptr)
            return;
        board[x][y] = '#';
        node = node->children[c - 'a'];
        if (node->word != "")
        {
            ret.push_back(node->word);
            node->word="";
        }
        for (int i = 0; i < 4; i++)
        {
            int newx = x + dirs[i][0];
            int newy = y + dirs[i][1];
            if (newx >= 0 && newx < board.size() && newy >= 0 && newy < board[0].size())
            {
                if (board[newx][newy] != '#')
                {
                    dfs(newx, newy, node, board);
                }
            }
        }
        board[x][y] = c;
    }
    vector<string> findWords(vector<vector<char>> &board, vector<string> &words)
    {
        Trie *root = new Trie();
        for (string s : words)
            insert(root, s);
        for (int i = 0; i < board.size(); i++)
        {
            for (int j = 0; j < board[0].size(); j++)
            {
                dfs(i, j, root, board);
            }
        }
        return ret;
    }
};
```






