---
title: 操作系统笔记整理10——输入输出系统（2）
toc: true
date: 2022-01-01 18:14:22
tags: 操作系统
categories: 操作系统
---

​​点击阅读更多查看文章内容<!--more-->

# [点此链接可跳转到：操作系统笔记整理——目录索引页](https://blog.csdn.net/shn111/article/details/122296621)
>参考书籍：《计算机操作系统》第四版 汤小丹等编著

>@[toc]

# 用户层I/O软件
用户层软件必须通过一组**系统调用**来取得操作系统服务。通过调用对应的**库函数**使用系统调用
I/O软件还包括运行在内核之外的守护进程（后台）等
## 系统调用
操作系统内核提供的一组功能强大的函数，在核心态下运行
系统调用是用户程序取得OS服务的唯一途径
当OS捕获到应用程序中的系统调用后，便将CPU的状态从用户态转换到核心态，然后转向操作系统中相应进程，由该过程完成所需的I/O操作，执行完成后，系统又将CPU状态从核心态转换到用户态，返回到应用程序继续执行。
## 库函数
库函数是系统调用的一种封装和扩展，工作在用户态
用户层 I/O 软件提供了一些读/写设备和控制/检查设备的库函数，以方便 用户取得 OS 的服务。
## 假脱机（Spooling）系统
**脱机输入输出技术**
为了缓和 CPU 的高速性与 I/O 设备的低速性间矛盾而引入，该技术在外 围控制机的控制下，先将低速I/O设备上的数据传送到高速磁盘上，或者相反，这样当处理机需要输入数据时，便可以直接从磁盘中读取数据，极大地提高了输入速度。反之，在输出数据时，也可以快速地把数据先输出到磁盘上，处理机便可去做其他的事情。
**假脱机技术**
当系统中引入了多道程序技术后，完全可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘上，再用另一道程序模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上
### SPOOLing的组成
1. 输入井和输出井（外存中）
   在**磁盘**上开辟出来的两个内存区域。输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据
2. 输入缓冲区和输出缓冲区（内存中）
   在**内存**中开辟的两个缓冲区，用于缓和 CPU、磁盘、I/O 设备之间速度不匹配的矛盾。输入缓冲区用于暂存由输入设备传送的数据，之后再传送到输入井。输出缓冲区用于暂存从输出井传送的数据，之后再传送到输出设备。
3. 输入进程和输出进程
   输入进程用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井，当CPU需要输入设备时，直接从输入井读入内存。
   输出进程也用于模拟脱机输出时的外围控制机，把用户要求输出的数据从内存传送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区输出至输出设备上。
4. 井管理程序
   用于控制作业与磁盘井之间信息的交换
   磁盘井 ⇔ 进程 buf ⇔ 用户进程

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/52799f7afd70b025c8f48118d989e701_1740931132747.png)
### SPOOLing系统的特点
1. 提高了I/O速度
   把对低速设备操作变为对输入/输出井的操作。
2. 将独占设备改造为共享设备。
   实际上并没有为任何进程分配设备，分配设备的实质是分配输入/输出井，并为进程分配一个存储区和建立一 张 I/O 请求表
3. 实现了虚拟设备功能。

# 缓冲区管理
**缓冲的引入**
1. 缓解 CPU 与 I/O 设备间速度不匹配的矛盾。
2. 减少中断 CPU 的次数。
   buffer 越大，“buffer 满”发生频率越低。
3. 解决数据粒度（即基本数据单元大小）不匹配的问题。
4. 提高 CPU 与 I/O 设备的并行性。

>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/53523059d8ac2007db2062fa4c99df0e_1740931132747.png)
>中断一次需要的时间（缓冲区满所用的时间，即中断一次所需的时间）
中断响应时间：CPU必须在下一数据写入缓冲区之前，对当前缓冲区中数据进行响应处理，否则缓冲区中的数据将会被覆盖掉。
## 单缓冲区和双缓冲区

### 单缓冲区
单缓冲区方式是在设备和处理机之间设置一个缓冲区。
设备与处理机交换数据时，先把交换的数据写入缓冲区，然后需要数据 的设备/处理机再从缓冲区中取走数据。
单缓冲区方式可以缓解 CPU 与 I/O 设备间速度不匹配的矛盾。
由于缓冲区属于临界资源，不允许多个进程同时对一个缓冲区操作，因 此在某一段时间内，缓冲区只能存放输入数据或输出数据（单向传输）。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/274ae2ef474fe27cc3e4655367617776_1740931132747.png)
无缓冲区时：处理一块数据的时间为:T+C
有缓冲区时：C和T是可以并行的，因此，处理一块数据的时间为:Max(C,T)+M
## 双缓冲区
>由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未取走缓冲区中的数据，即使生产者生产出新的数据，也无法将它送入缓冲区，生产者需等待。由此，引入双缓冲区，便能解决这一问题。

双缓冲区方式是在设备和处理机之间设置两个缓冲区。

在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3e6e124bbee2bbbbfec603b19760199e_1740931132747.png)
M与T可以并行，C与T也可以并行，因此处理一块数据的时间为：Max(C+M,T)，通常 M≪T，因此处理一块数据的时间可以粗略地估计为Max(C,T)。
如果C<T,可使块设备连续输入
如果C>T,可使CPU不必等待设备输入

## 环形缓冲区
>当输入输出的速度基本相等时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。但若两者的速度相差甚远，双缓冲的效果则不够理想，不过可以随着缓冲区和数量的增加，使情况有所改善。因此，又引入了多缓冲机制，可将多个缓冲区组织成环形缓冲区形式。

### 环形缓冲区的组成
**多个缓冲区**：
在设备和处理机之间设置多个大小相等的缓冲区，这些缓冲区构成环形。作为输入的多缓冲区可分为三种类型：用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的现行工作缓冲区C
**多个指针**：
Nexti：指示下次可用的空缓冲区的指针
Nextg：指示下次可用的数据缓冲区的指针
Current：指示正在使用的缓冲区的指针

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/18769a59d356185d0f8c7ffcfc432369_1740931139431.png)
### 环形缓冲区的使用
**Getbuf过程**：
计算进程：调用Getbuf过程，取Nextg对应缓冲区使用，须把它改为现行工作缓冲区，并令Current指针指向该缓冲区的第一个单元，同时将Nextg对应的缓冲区置为空，Nextg=（Nextg+1）Mod N
输入进程：调用Getbuf过程，取Nexti对应缓冲区使用，将Nexti对应的缓冲区置为满，Nexti=（Nexti+1）Mod N
**Releasebuf过程**
输入进程：把C装满后，调用Releasebuf过程释放缓冲区，改为G
计算进程：把C的数据提取完毕后，调用Releasebuf过程释放缓冲区，改为R
### 进程之间的同步问题
指针 Nexti 和指针 Nextg 将不断地沿着顺时针方向移动。
Nexti 追上 Nextg：表示输入速度 > 输出速度，全部 buf 满，再无空 buf 可用，这时输入进程阻塞。这种情况被称为系统受计算限制。
Nextg 追上 Nexti：输入速度 < 输出速度，全部 buf 空，这时输出进程阻塞。这种情况被称为系统受 I/O 限制。
## 缓冲池
>上述三种缓冲区的组织形式仅适用于某种特定的 I/O 进程和计算进程，属于专用缓冲。当系统中的设备很多时，将会有许多这样的循环缓冲区，消耗大量的内存空间，而且其利用率也不高。为了提高缓冲区的利用率，可以采用公共缓冲池技术，在池中设置了多个可供若干个进程共享的缓冲区。缓冲池与缓冲区的区别在于：缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区。

### 缓冲池的组成
1. 空白缓冲队列emq：由空缓冲区所链成的队列。其队首指针F(emq)和队尾指针L(emq)分别指向该队列的首缓冲区和尾缓冲区
2. 输入队列inq：由装满输入数据的缓冲区所链成的队列，队首指针F(inq),队尾指针L(inq)
3. 输出队列outq：由装满输出数据的缓冲区所链成的队列，队首指针F(outq),队尾指针L(outq)
4. 收容输入缓冲区hin
5. 提取输入缓冲区sin
6. 收容输出缓冲区hout
7. 提取输出缓冲区sout
   
### getbuf过程和putbuf过程
Addbuf(type,number) 过程：用于将参数 number 所指示缓冲区挂在 type队列上。
Takebuf(type) 过程：用于从 type 所指示的队列的队首摘下一个缓冲区。 
MS(type)：互斥信号量，使诸进程互斥地访问缓冲池队列
RS(type)：资源信号量（如缓冲队列中缓冲区的数量），保证诸进程同步地使用缓冲区
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3500e262add4c22ffc0a1833dc79f612_1740931139431.png)
### 缓冲池的工作方式
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/cb69e72a39ff9d0a951856e80ddcbb2f_1740931139431.png)
1. 收容输入：输入进程调用Getbuf(emq)过程，从空缓冲队列emq的队首摘下一空缓冲区，把它作为收容输入工作区hin。然后，把数据输入其中，装满后再调用Putbuf(inq,hin)，将它挂在输入队列inq的末尾。
2. 提取输入：计算进程调用Getbuf(inq)过程，从输入队列inq队首取得一缓冲区，作为提取输入工作缓冲区sin，计算进程用完该数据后，再调用Putbuf(emq,sin)过程，将它挂到空缓冲队列emq末尾
3. 收容输出：计算进程调用Getbuf(emq)，从空缓冲队列emq的队首取得一空缓冲作为输出工作缓冲区hout，当其中装满输出数据后，又调用Putbuf(outq,hout)过程，将它挂在outq末尾
4. 提取输出：输出进程调用Getbuf(outq)过程，从输出队列的队首取得一装满输出数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完后，再调用Putbuf(emq,sout)，将它挂在emq末尾
   
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/330545feeddeae64dafacdad718ce105_1740931139431.png)
# 磁盘存储器的性能和调度
## 磁盘结构
- 磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁盘的 0 磁道在最外圈
- 柱面：不同盘片相同半径的磁道所组成的圆柱称为柱面
- 扇区：磁道被划分成一段段的圆弧，每段圆弧叫做一个扇区。**扇区是磁盘最小的物理存储单元**
- 簇：簇是操作系统使用的逻辑概念(分配的最小单位)，相邻的扇区组合在一起，形成一个簇

## 数据的组织
磁盘结构：盘面、磁道、扇区
磁盘物理块的地址：磁头号、柱面号、扇区号
存储容量=磁头(盘面)数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数

**磁盘类型**：
固定头磁盘：每条磁道上都有一个磁头
移动头磁盘：每个盘面上都有一个磁头

**磁盘格式化**：
低级格式化：物理级的格式化，主要是用于划分硬盘的磁柱面、建立扇区数和选择扇区间隔比。
高级格式化：清除硬盘上的数据、生成引导区信息、初始化FAT表、标注逻辑坏道等。
> 温彻斯特盘低级格式化
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/1f2a6bf53e38fac1ad24074fe295db2b_1740931139431.png)
> 每个扇区容量为 600 个字节，其中 512 个字节存放数据，其余用于存放 控制信息。每扇区包括两个字段：
> 标识符字段：其中一个 SYNCH 字节（同步字节）用于标识一个扇区，
> CRC 字段用于段校验（循环冗余码校验）。 数据字段：其中可存放 512 个字节的数据。
> 为了简化和方便磁头的辨识，在一个盘面的不同磁道、一个磁道的不同扇区、一个扇区的不同字段之间都设置了一个到若干个不同长度的间距(Gap)
## 磁盘访问时间
**寻道时间T~s~**：
磁头定位到磁道所需时间
T~s~ = m × n + s
s 为启动磁臂的时间，n 为移动的磁道数，m 为常数与磁盘驱动器的速度有关。

**旋转延迟时间T~r~**：
扇区移动到磁头下面所经历的时间
T~r~ ＝ 1/2r（均值）
r为磁盘每秒钟的转数

**传输时间T~t~**：
数据从磁盘读出或向磁盘写入数据所经历的时间
T~t~= b/rN
r为磁盘每秒钟的转数，N为一条磁道上的字节数，b为每次读/写的字节数

访问时间T~a~ = m × n + s + 1/2r + b/rN
>**例1**：考虑一个磁盘系统。平均寻道时间是 4ms，转速是 7500rpm，忽略控制器的开销。每个磁道有 500 个扇区，每个扇区 512 字节。假设读取一个包括2500 个扇区的文件（文件大小为 1.28MB），试估计传送需要的总时间。
>1.假设文件尽可能紧凑地保存在磁盘上，占据 5 个相邻磁道的所有扇区（5×500）。读取第一条磁道的时间：
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/bd05eaf46cd9f0e287e75dea66a163cf_1740931146901.png)
>读取第一条磁道的时间为 16ms。 读取整个文件的时间：
>后面的 4 个磁道不再需要寻道时间，每个磁道可以在 4+8=12ms 内读入。
>总时间 = 16 + (4 × 12) = 64ms = 0.064s
>2.假设文件随机地分布在磁盘上。读取整个文件的时间：
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/5c3361d795759b4d4e881fe363613f0b_1740931146901.png)

>例2
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cfd89b779d2ebb370cda0c3f5b0b8bbd.png)![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fe5ed9e2b2110655299a9198d54abdb1.png)![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3938fc2ff272b3d9c3f37e31e43a01c5_1740931146901.png)




## 磁盘调度算法
### 先来先服务算法(FCFS)
只考虑申请者申请的先后次序完成磁盘访问操作
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/8e70f790c83c69e9e7046561110a2ed6_1740931146901.png)
磁头臂来回反复移动，增长了等待时间，对机械结构不利。
### 最短寻道时间优先算法(SSTF)
选择要求访问的磁道与当前磁头所在磁道距离最近的访问，以使每次的寻道时间最短，但不能保证平均寻道时间最短
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/8df48f82817ea0b6a337679cad3c56ba_1740931146901.png)

**缺点**：
磁臂粘着：在最短寻道时间优先调度算法中，可能出现磁臂停留在某处的 情况，即反复请求某一磁道，从而垄断了整个磁盘设备，这种现象称为磁臂粘着。
磁道歧视：假设某一时刻外磁道请求不断，则内磁道请求可能长时间得不 到满足，这种现象称为“磁道歧视”。因此 SSTF 算法缺乏公平性，存在饥饿和饿死的问题。
**磁盘的0磁道在最外圈**
### 扫描算法(Scan)
>扫描算法一直移动到最内柱面，LOOK算法（电梯算法）一旦内柱面没有访问请求就改变移动方向，不扫描到头。这里不做区分，统一按照LOOK算法解决

无访问请求时，磁头引臂停止不动；当有访问请求时，起始时磁头由外柱面向内柱面移动，并为途经的请求服务。一旦内柱面没有访问请求， 则改变移动方向（如外柱面有请求）或停止移动（外柱面也无请求）。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/76495e3319c48a7d2de42862cb5ac162_1740931153814.png)
对于 SCAN(LOOK) 算法来说，位于不同磁道（柱面）的 I/O 请求与获取 服务所需的等待时间是不同的。
对于靠近边缘的柱面，最坏情况的移动量为2N-1（N 为柱面数）；对于 靠近中部的柱面，最坏情况为N-1。平均情况分别约为 N 和 N/2。
### 循环扫描算法(CSCAN)
循环扫描算法是为了消除边缘柱面与中部柱面等待时间差异而进行的改进。
磁头只在单方向移动过程中才为途经的请求服务，一旦达到边缘，则立 即快速移动至另一边缘，在此移动过程中并不处理访问请求，然后重新 开始新一轮扫描。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/a9f349d060c6c7803e382a585b3bcd7f_1740931153814.png)

### NStepSCAN算法
将磁盘请求队列分成若干个长度为 N 的子队 列，磁盘调度将按 FCFS 算法依次处理这些子队列，而每一子队列按SCAN 算法处理。
N=1	⇒ FCFS 算法
N 很大	⇒ SCAN 算法
### FSCAN算法
FSCAN 算法实质上是 N 步 SCAN 算法的简化。FSCAN 只将磁盘请求 队列分成两个子队列。一个是由当前所有请求磁盘 I/O 的进程形成的队列，由磁盘调度按 SCAN 算法进行处理。另一个是在扫描期间，将新出现的所有请求磁盘 I/O 的进程放入另一个等待处理的请求队列。这样所有的新请求都将被推迟到下一次扫描时处理。



