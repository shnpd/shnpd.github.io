---
title: 操作系统笔记整理7——存储器管理（2）
toc: true
date: 2021-12-30 20:48:18
tags: os 操作系统
categories: 操作系统
---

​​点击阅读更多查看文章内容<!--more-->

# [点此链接可跳转到：操作系统笔记整理——目录索引页](https://blog.csdn.net/shn111/article/details/122296621)
>参考书籍：《计算机操作系统》第四版 汤小丹等编著

>@[toc]

# 离散分配方式
连续分配存储管理方式产生的问题：
1.要求连续的存储区
2.碎片问题

变连续分配为离散分配，允许将作业离散放到多个不相邻接的分区中

离散分配方式包括：
1.分页式存储管理：离散分配的基本单位是页
2.分段式存储管理：离散分配的基本单位是段
3.段页式存储管理：离散分配的基本单位是段、页
# 分页存储管理方式
## 页面和物理块
**空间划分**：
将一个用户进程的地址空间（逻辑空间）划分成若干个大小相等的区域，称为<font color="red">页</font>或页面，各页从0开始编号。
内存空间也分成若干个与页大小相同的区域，称为<font color="red">块</font>，同样从0开始编号
**内存分配**：
在为进程分配内存时以块为单位，将进程中若干页装入到多个不相邻的块中，最后一页常装不满一块而出现页内碎片
## 地址结构
**逻辑地址**：
![](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/dedf0815fa70f0e55de49e0d543a105f_1740931194253.png)
地址长为32位
其中0-11位为页内地址，即每页的大小为2^12^=4KB；
12-31位为页号，地址空间最多允许有2^20^=1M页。
**物理地址**：
![](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/cee543fee501755563b215e35c00980b_1740931194253.png)
地址长为22位
其中0-11位为块内地址，即每块的大小为2^12^=4KB，与页相等
12-21位为块号，内存地址空间最多允许有2^10^=1K块
## 页表
分页系统为每个进程配置一张页表，放在PCB中，执行时装入页表寄存器（PTR），进程逻辑地址空间中的每一页，在页表中都对应有一个页表项
页表存放在内存中，属于进程的现场信息
用途：1.记录进程的内存分配情况 　　2.实现进程运行时的动态重定位
<font color="red">访问一个数据需访问内存两次，页表一次，内存一次</font>
页表的基址及长度由**页表寄存器**给出
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/560a75a47c6e4646f8df021ac45da011_1740931194253.png)
关于页面大小的问题：
若页面较小：减少了页内碎片，但使页表长度增加，占用内存较大，页面换进换出的速度将降低
若页面较大：页表长度减少，占用内存较小，页面换进换出的速度将提高，但增加了页内碎片，不利于提高内存利用率

## 地址变换机构
将用户地址空间中的逻辑地址变换为内存空间中的物理地址
### 基本的地址变换机构
地址变换借助页表来完成，页表驻留内存
1.逻辑地址: 把相对地址分为页号和页内地址两部分。
2.越界中断: 页号与页表长度做比较，若页号大于等于页表长度，则产生地址越界中断
3.页表项定位：页表始址 + 页号 × 页表项长度。
4.查询页表：读出块号。
5.物理地址：块号 + 块内地址。（块内地址 = 页内地址）
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/82c662adc1175a4c974f7c3cb2a1a2d3_1740931194253.png)
> 例题
> 例：存储器的用户空间共有 32 个页面，每页 1KB，内存 16KB。假定某时刻系统为用户的第 0、1、2、3 页分别分配的物理块号为 5、10、4、7，试 将逻辑地址 0A5C 和 093C 变换为物理地址。
> 解：逻辑地址为：共有32个页，页号5位（2^5^=32），每页1KB，页内位移10位；
> 物理地址为：内存16KB，每块1KB，共有16块，物理块号4位（2^4^=16），每块1KB，块内位移10位。
> 逻辑地址 0A5C 对应的二进制为：00010 1001011100，前五位00010为页号，后十位1001011100为页内偏移，第2页对应的块号为4
> 故物理地址为0100 1001011100即125C
> 同理可求 093C 的物理地址为 113C。
### 具有快表的地址变换机构
基本的地址变换机构因为两次访问内存，所以地址变换速度低
**具有快表的地址变换机构**：
目的：提高地址变换速度
快表：又称为联想寄存器
快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容
CPU产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将之复制到快表。若快表中内容满，则按某种算法淘汰某些页。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ac2587984a76dac5d7d32d4580980c2.png)　![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/a7da58904dc404185ce324680997b6c6_1740931202913.png)

## 访问内存的有效时间
有效访问时间（Effective Access Time,EAT）是指从给定逻辑地址，经过地址变换，到在内存中找到对应物理地址单元并取出数据所用的总时间
- 基本地址变换机构
  设T~M~为内存的访问时间  
  EAT=2T~M~
- 具有快表的地址变换机构
  设P~TLB~为快表的命中率，T~TLB~为快表的访问时间
  EAT=P~TLB~*（T~TLB~+T~M~）+（1-P~TLB~）\*（T~TLB~+2T~M~）
## 多级页表
若逻辑地址空间很大，则划分的页比较多，页表就很大，占用的存储空间大，实现较困难
### 两级页表
将页表再进行分页，离散地将各个页表页面存放在不同的物理块中，同时也再建立一张外部页表用以记录页表页面对应的物理块号
正在运行的进程，必须把外部页表调入内存，而动态调入内部页表。只将当前所需的一些内层页表装入内存，其余部分根据需要再陆续调入
**逻辑地址**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/d57590badcf35a22549842be80c41ff0_1740931202913.png)

**地址变换**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/ee6a1d0f78f201c97e79276073681164_1740931202913.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/f95e3896d6fe4b2fabbe9d79e97a3908_1740931202913.png)

### 多级页表
将外层页表再进行分页，也将各外层页表页面离散地存放在不同的物理块中
**逻辑地址**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/c723c4ba4ea2837275d8a3fa6e0f599f_1740931202913.png)
## 反置页表
对于 64 位逻辑地址空间的分页系统，如果规定页面大小为 4 KB 即 2^12^B，则在每个进程页表就由高达 2^52^ 页组成。设表中每项为 8byte，则 需 8 ∗2^52^ =2^55^ =32768 TB 的内存空间。
一般页表的页表项是按页号进行排序，页表项中的内容是物理块号
反置页表是为每一个**物理块**设置一个页表项并按物理块号排序，其中的内容是**页号**P及隶属**进程标志符**pid

利用反置页表进行地址变换：
1. 用进程标志符和页号去检索反置页表
2. 如果检索完页表没有找到与之匹配的页表项，表明此页尚未调入内存
3. 如果检索到，则表项的**序号**i表示该页的**物理块号**，将该块号与页内地址一起构成物理地址
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/7ee4b0fddaa202b7f600218185103ebf_1740931209630.png)
反置页表可以有效减少页表占用的内存，但反置页表中只包含已经调入内存的页面，因此必须为每个进程建立一个外部页表，发现页面不在内存时才访问外部页表。
外部页表存放各页在外存中的物理位置。通过外部页表可将所需要的页面调入内存
## 页的共享与保护
**页的共享**
各进程把需要共享的数据/程序的相应页指向相同物理块
**页的保护**
地址越界保护
在页表中设置保护位（定义操作权限：只读，读写，执行等）
**共享带来的问题**
若共享数据与不共享数据划在同一块中，则：有些不共享的数据也被共享，不易保密；计算共享数据的页内位移较困难

实现数据共享的最好方法：<font color="red">分段存储管理</font>
# 分段存储管理方式
引入分段存储管理是为了满足用户的要求
1. 方便编程：通常一个作业是由多个程序段和数据段组成的，一般情况下，用户希望按逻辑关系对作业分段，并能根据名字来访问程序段和数据段
2. 信息共享：共享是以信息的逻辑单位为基础的。页是存储信息的物理单位，段却是信息的逻辑单位；页式管理中地址空间是一维的，主程序，子程序都顺序排列，共享公用子程序比较困难，一个共享过程可能需要几十个页面
3. 信息保护：页式管理中，一个页面中可能装有两个不同的子程序段的指令代码，不能通过页面共享实现共享一个逻辑上完整的子程序或数据块。段式管理中，可以以信息的逻辑单位进行保护
4. 动态增长：实际应用中，某些段（数据段）会不断增长，前面的存储管理方法均难以实现。
5. 动态链接：动态链接在程序运行时才把主程序和要用到的目标程序（程序段）链接起来。
   
**空间划分**
将用户作业的逻辑地址空间划分成若干个**大小不等**的段。各段有段名，首地址为0

## 利用段表实现地址映射
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/5946c749081696234364befd8d0ea529_1740931209630.png)
- 段表记录了段与内存位置的对应关系
- 段表保存在内存中
- 段表的基址及长度由段表寄存器给出
- 访问一个字节的数据/指令需访问内存两次（段表一次，内存一次）
- 逻辑地址由段号和段内地址组成  
## 地址变换机构
系统将逻辑地址中的段号S与段表长度TL进行比较
　　若S>TL，表示段号太大，产生越界中断信号
　　若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的始址
再检查段内地址d，是否超过该段的段长SL
　　若超过，同样发出越界中断信号
　　若未越界，则将该段的基址与段内地址d相加，即可得到要访问的内存物理地址
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/2c193c15fb19708d160d99bacf51719f_1740931209630.png)

## 信息共享
例：一个多用户系统，可同时接纳40个用户，都执行一个文本编辑程序(Text Editor)。如果文本编辑程序有160KB的代码和另外 40 KB 的数据区，如果不共享，则总共需有8MB的内存空间来支持40个用户。
如果 160 KB 的代码是可重入的，则无论是在分页系统还是在分段系统中，该代码都能被共享。
在内存中只需保留一份文本编辑程序的副本，此时所需的内存空间仅为1760 KB(40×40+160)，而不是 (160+40)×40= 8000KB 。
**分页系统的共享**
假定每个页面的大小为4KB，160KB的代码将占用40个页面，数据区占10个页面
为实现代码的共享，应在每个进程的页表中都建立40个页表项，它们的物理块号是21\~60。在每个进程的页表中，数据区页表项的物理块号是61\~70、71~80
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/418824adab6e36f209e5bea62bf76e79_1740931209630.png)

**分段系统的共享**
在分段系统中，实现共享容易的多，只需在每个进程的段表中为文本编辑程序设置一个段表项
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/10c1a8d5af931761c47d6933bc3c7716_1740931209630.png)
# 分页与分段的主要区别
- 页是信息的<font color="red">物理</font>单位，分页仅仅是由于系统管理的需要，对用户透明的。段是信息的<font color="red">逻辑</font>单位，分段的目的是为了能更好的满足用户的需要。
- 页的<font color="red">大小固定</font>且由系统确定，把逻辑地址划分为页号和页内地址两部分。段的长度<font color="red">不固定</font>，决定于用户所编写的程序
- 分页的作业地址空间是<font color="red">一维</font>的，分段的作业地址空间是<font color="red">二维</font>的
- 页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/acfcd7b61483fa0fc282902e8b7edce6_1740931218965.png)
# 段页式存储管理方式
段页式存储管理是分段和分页原理的结合，即先将用户程序分成若干个段，并为每一个段赋一个段名，再把每个段分成若干个页
其地址结构由段号、段内页号及页内位移三部分所组成
系统中设段表和页表，均存放于内存中。读一字节的指令或数据须访问内存三次。
每个进程一张段表，每个段一张页表
段表含段号、页表始址和页表长度
页表含页号和块号

## 段页式存储管理的地址变换
1. 从PCB中取出段表始址和段表长度，装入段表寄存器
2. 将段号与段表长度进行比较，若段号大于或等于段表长度，产生越界中断
3. 利用段表始址与段号得到该段表项在段表中的位置。取出该段的页表始址和页表长度
4. 将页号与页表长度进行比较，若页号大于等于页表长度，产生越界中断
5. 利用页表始址与页号得到该页表项在页表中的位置
6. 取出该页的物理块号，与页内地址拼接得到实际的物理地址
   ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3e54dbf18d43710129394ef9b823ade3_1740931218965.png)


