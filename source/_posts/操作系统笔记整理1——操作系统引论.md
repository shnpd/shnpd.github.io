---
title: 操作系统笔记整理1——操作系统引论
toc: true
date: 2021-12-28 17:53:12
tags: 操作系统
categories: 操作系统
---

​​点击阅读更多查看文章内容<!--more-->

# [点此链接可跳转到：操作系统笔记整理——目录索引页](https://blog.csdn.net/shn111/article/details/122296621)

> 参考书籍：《计算机操作系统》第四版 汤小丹等编著

>  @[toc]

# 操作系统的作用

 - 作为用户与计算机硬件系统之间的接口
 - 作为计算机系统资源的管理者
 - 实现了对计算机资源的抽象
# 单道批处理系统
作业逐个送入内存运行
特征：自动型、顺序性、单道性
优点：减少了人工操作的时间，缓解了一定程度的人机速度矛盾，资源利用率有所提升。
缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序，CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/d0654354b016839b134f5dd2b780e306_1740931315914.png)
# 多道批处理系统
解决单道批处理系统中内存仅存放一道作业，导致资源利用率和吞吐量低下的问题
多个作业先在外存“后备队列”中排队，经作业调度选择若干个调入内存，使它们共享CPU和系统中的各种资源。
特征：调度性、无序性、多道性
优点：资源的利用率高、系统吞吐量大
缺点：平均周转周期长、无交互能力


> 例题：A、B 两个程序，程序 A 按顺序使用 CPU 10s，设备甲 5s，CPU 5s，  设备乙 10s，CPU 10s，程序 B
> 按顺序使用设备甲 10s，CPU 10s，设备乙 5s，CPU 5s，设备乙 10s。 
> 问：
> 1、在顺序环境下执行程序 A 和 B，CPU利用率多少？    2、在多道环境下呢？
> 答：
> 1、A 和 B 顺序执行时，A 执行完毕 B 才开始，总共耗时 80s，占用 CPU40s，故利用率为 40/80=50%。
> 2、
> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/b7e6b3cd14e23db5294f0e9694209c79_1740931315914.png)
> 多道时，两程序共耗时 45s, 占用 CPU 40s, 故利用率 40/45=88.89%。


>- 批处理操作系统的特征：
>1. 脱机：是指用户脱机使用计算机，即用户提交作业之后直到获得结果之前几乎不再和计算机打交道。
>2. 多道：是指多道程序运行，即按多道程序设计的调度原则，从一批后备作业中选取多道作业调入内存并组织它们运行；
>3. 成批处理：是指操作员把用户提交的作业组织成一批，由操作系统负责每批作业间的自动调度。 
>- 分时操作系统的特征：
>1. 多路性：系统按分时原则为多个终端用户提供服务，允许多个用户共享一台计算机。
>2. 独立性：每个用户在各自的终端上进行操作，彼此之间互不干扰
>3. 及时性：用户的请求能在很短的时间内获得相应
>4. 交互性：用户可以通过终端与系统进行广泛的人机对话
>- 实时操作系统的特征：
>1. 多路性：系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制
>2. 独立性：对信息的采集和对对象的控制彼此互不干扰
>3. 及时性：是指系统能及时响应外部事件的请求，并在规定时间内完成对该事件的处理
>4. 交互性：仅限于用户发送某些特定的命令，如开始、停止、快进等，由系统立即响应。
>5. 可靠性：是指系统本身要安全可靠，因为像生产过程的实时控制、航空订票等实时事务系统，信息处理的延误或丢失往往会带来不堪设想的后果。
# 操作系统的特征

 - **并发性（最重要特征）**： 在一段时间内同时存在多道运行的程序（进程）
 宏观上：多道程序同时执行
 微观上：在单处理机系统中，任何时刻只有一道程序在执行，即微观上多道程序在CPU上交替执行。
并行：多道程序在**同一时刻**执行
 - **共享性**：指系统中的资源不再为某道程序所独占，而是供多道程序共同使用。
 
   **<font  color="blue">并发性和共享性是操作系统的两个最基本的特征</font>**
 - **虚拟性**：指把一个物理实体映射为若干个对应的逻辑实体。
 时分复用：即分时使用方式。如：虚拟处理机、虚拟设备。
 空分复用：用于提高存储空间的利用率。如：虚拟磁盘、虚拟存储器。
 - **异步性**：异步性也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和时间等都是不可预知的。
 
# 操作系统的功能
 - 处理机管理
 
 进程控制：状态转换
 进程同步：协调运行进程
 进程通信：合作进程信息交换
 调度 ：作业调度+进程调度
- 存储器管理

内存分配：为每道程序分配内存空间
内存保护：确保用户程序在自己的内存空间运行，互不干扰，不允许其访问操作系统的程序和数据，也不允许其转移到非共享的其他用户程序中执行
地址映射：逻辑地址->物理地址
内存扩充：虚拟存储技术

- 设备管理

缓冲管理：单缓冲、双缓冲、缓冲池
设备分配：根据用户请求和系统现有资源分配其所需设备
设备处理：设备处理程序又称为设备驱动程序，实现CPU和设备控制器之间的通信
虚拟设备

- 文件管理

文件存储空间的管理
目录管理
文件的读/写管理和保护
- 用户接口

用户接口：联机用户接口、脱机用户接口、图形用户接口
程序接口：为用户程序访问系统资源而设置的，是其获得操作系统服务的唯一途径
# 微内核操作系统
当前比较流行的操作系统几乎全部采用微内核结构

为了提高灵活性和可扩充性，OS分为：微内核、用于提供各种服务的一组服务器

**微内核**：能实现现代OS核心功能的小型内核，运行在核心态下，开机后常驻内存，不会因内存紧张而换出。
 1.实现与硬件紧密相关的处理
 2.实现一些较基本的功能（如地址变换）
 3.负责客户和服务器之间的通信


**微内核OS技术的主要思想**：在内核中留下一些最基本的功能，而将其他服务分离出去，由工作在用户态下的进程来实现，形成所谓“客户/服务器”模式。客户进程可通过内核向服务器进程发送请求，以取得OS的服务。

## 微内核的结构
- **足够小的内核**
微内核并非是一个完整的OS，而只是将OS中最基本的部分放入微内核，通常包含有：
①.与硬件处理紧密相关的部分；
②.一些较基本的功能；
③.客户和服务器之间的通信

- **基于客户/服务器模式**
将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在内核外面的一组服务器（进程）中实现，如用于提供对进程(线程)进行管理的服务器等，它们都是被作为进程来实现的，运行在用户态。
客户和服务器之间是借助微内核提供的消息传递机制来实现信息交互的
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/106c6104ebbf346464bf6f8a50bbe298_1740931315914.png)
- **应用“机制与策略分离”原理**
机制：指实现某一功能的具体执行机构
策略：在机制的基础上，借助于某些参数和算法来实现该功能的方法。
简单理解：软件是策略，硬件是机制。命令是策略，实施是机制
微内核操作系统：只把机制放在OS的微内核中，把策略从内核中分离出去，可以把内核做得很小。 
- **采用面向对象技术**

## 微内核的基本功能
-  进程(线程)管理
采用“机制与策略分离”的原理。例如：为实现进程调度，须在内存中设置一个或多个进程优先级队列，将制定进程从队列中调出，并投入执行。这一部分属于调度功能的**机制**部分，将其放入微内核中。而对于进程如何分类，以及优先级的确认方式或原则，都属于策略问题。放入微内核外的进程管理服务器中
- 低级存储器管理
在微内核中，通常只配置最基本的低级存储器管理机制，如用于实现逻辑地址到物理地址的变换的页表机制和地址变换机制，这一部分依赖于硬件，放入微内核。而实现虚拟存储器管理的策略，则包含页面置换算法以及内存分配与回收策略的选择等，这部分应放在微内核外的存储器管理服务器中去实现。
- 中断和陷入处理
大多数微内核操作系统都是将与硬件紧密相关的一小部分放入微内核中处理，此时微内核的主要功能就是捕获所发生的中断和陷入事件，并进行相应的前期处理，如现场保护，识别中断类型，将有关信息转化成消息后，再把它发送给相关服务器，由服务器进行后期处理



**处理机状态**：处理机至少需要两种独立的操作模式：核心态和用户态
核心态：又称系统态或管态，是操作系统运行时所处的状态。处理机处于核心态时可以执行硬件所提供的全部指令，包括特权指令和非特权指令。
用户态：又称为目态，是一般用户程序运行时所处的状态。处理机处于用户态时只能执行非特权指令。
用户态下程序不能将其运行状态改为核心态，这样就可以防止用户有意或无意的侵入系统，从而起到系统保护的作用。 

## 微内核操作系统的优缺点
**优点**：
- 提高了系统的可扩展性
- 增强了系统的可靠性
- 可移植性强
- 提供了对分布式系统的支持
- 融入了面向对象技术

**缺点**：
- 运行效率有所降低，在完成一次客户对操作系统提出的服务请求时，需要进行四次上下文切换：1.客户发送消息给内核；2.内核把消息发给服务器；3.服务器把相应消息发给内核；4.内核将响应消息发给客户；这在早期的OS中，一般只需要两次切换：1.执行系统调用后由用户态转向系统态；2.在系统完成用户请求的服务后，由系统态返回用户态。

