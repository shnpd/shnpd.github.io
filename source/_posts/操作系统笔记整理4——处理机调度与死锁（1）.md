---
title: 操作系统笔记整理4——处理机调度与死锁（1）
toc: true
date: 2021-12-29 01:21:01
tags: 操作系统
categories: 操作系统
---

​​点击阅读更多查看文章内容<!--more-->

# [点此链接可跳转到：操作系统笔记整理——目录索引页](https://blog.csdn.net/shn111/article/details/122296621)
> 参考书籍：《计算机操作系统》第四版 汤小丹等编著

>@[toc]

# 处理机调度的层次
1.高级调度（作业调度）
从外存后备队列中选择作业进入内存就绪队列
2.中级调度（交换调度）
在内存和外存对换区之间按照给定的策略选择进程对换
3.低级调度（进程调度）
从就绪队列中选择一个进程来执行并由分派程序分配处理机
是OS中最基本的调度
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/917b1f8d2c427d8619888bf59f4269b4_1740931263995.png)
CPU的利用率=$\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$
周转时间=结束时间-到达时间
带权周转时间=$\frac{周转时间}{系统服务时间}$
<font color="red">带权周转时间越小越好</font>
# 作业调度
**作业**：作业是把命令、程序和数据按照预先确定的次序结合在一起，并提交给系统的一个组织单位。
作业控制块JCB是作业在系统中存在的唯一标志
作业运行时首先被调度进入内存，并以进程的形式存在，其状态是执行状态，处于执行状态的作业可以有多个，处于执行状态的作业并不意味着一定在CPU上运行，是否运行依赖于进程控制。
## 先来先服务调度算法FCFS
按进程（作业）进入就绪（后备）队列的先后次序来分配处理机（为期创建进程）
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/6053e4e0bc46bad85c16d833a001dfe2_1740931263995.png)
**特点**：简单，但效率不高，有利于CPU繁忙型作业，不利于I/O繁忙型作业
## 短作业优先调度算法（SJF）
用于作业调度，主要任务是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存
类似地，用于进程的是短进程优先调度算法（SPF）
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/eef7fae604b8765b46585b9659573f19_1740931263995.png)
能有效降低作业的平均等待时间和平均周转时间，提高了吞吐量，但是对长作业不利，没有考虑作业的紧迫程度，作业执行时间、剩余时间仅为估计。
## 优先级调度算法（PSA）
PSA：Priority scheduling algorithm
以作业的紧迫程度为优先级
静态优先级：优先权在创建进程时确定，且在整个运行期间保持不变
动态优先级：在进程的存在过程中不断发生变化
## 高响应比优先算法（HRRN）
HRRN：Highest response ratio next
高响应比优先算法既考虑了作业的等待时间，也考虑的作业的运行时间，是是一种动态优先级调度算法
**<font color="red">优先权=$\frac{等待时间+要求服务时间}{要求服务时间}$<font>**

**例题**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/1d7a6f6394a4cf9eb55346881a73cec1_1740931270838.png)
# 进程调度
任务：保存处理机的现场信息、按某种算法选取进程、把处理机分配给进程
## 最短剩余时间调度算法（SRT (Shortest Remaining Time)）
最短剩余时间调度算法是针对SPF(短进程优先)增加了抢占机制的一种调度算法
它总是选择**预期剩余时间最短的进程**。只要新进程就绪，且有更短的剩余时间，调度进程就可能抢占当前正在运行的进程。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/aa268ac224dcff48e42d75cce8fed8fe_1740931270838.png)

## 时间片轮转调度算法（RR）
系统将所有就绪进程按FCFS的原则，排成一个队列依次调度，把CPU分配给队首进程，并令其执行一个时间片，通常为10-100ms,时间片用完后，系统的计时器发出时钟中断，该进程将被剥夺CPU并插入就绪队列末尾

**进程切换时机**：
1.一个时间片尚未用完进程便已完成，立即在调度就绪队列中队首进程运行，并启动一个新的时间片
2.如果在一个时间片用完时进程尚未运行完毕，则剥夺CPU，调度程序把它送完就绪队列的末尾。

响应时间T=时间片q*就绪队列进程数n
>例：一个分时OS，10个终端，时间片100ms，每个用户的请求进程要300ms的时间处理，问终端用户提出二次请求的时间间隔最少是多少？
>响应时间=100ms*10=1s，每个用户的请求要3个时间片才能处理完，要轮转3次，所以终端用户的二次请求的时间间隔最少应为2.1s~3s

>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/d429bd785fa423d11f9de1800823e045_1740931270838.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/70b143b7116386d123bcf026bd093831_1740931270838.png)
## 优先级调度算法
**非抢占**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/a8fd6893b2b0aec80add0fb440dfdd49_1740931270838.png)
**抢占**
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/8b2658bc317b295864960a9b7fdb27ed_1740931278021.png)
## 多级队列调度算法
将就绪队列划分成若干个独立的队列，每个作业固定地分属一个队列，不同的队列可以采用不同的调度算法

### 多级反馈队列调度算法
FCFS+优先级+RR+抢占
1.设置多个就绪队列，队列1的优先级最高，其余队列逐个降低
2.每个队列中进程执行的时间片大小各不相同，进程所在队列的优先级越高，时间片就越短
3.新进程进入系统，先放入队列1的末尾，按FCFS调度，若能完成则撤离系统，反之调入队列2，按FCFS调度，如此下去，最后进入队列n按RR算法调度
4.仅当队列1为空时，才调度队列2中的进程运行。若一个队列中的进程正执行，此时有新进程进入高级队列，则新进程**抢占运行**，原进程移至本队队尾。 
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/df28feb34a81b71231b99d643482e1e8_1740931278021.png)
# 实时调度
实时调度的基本条件：
1.提供必要的调度信息
2.系统处理能力强
3.采用抢占式的调度机制
4.具有快速切换机制

## 限制条件
m：实时任务数；Ci：每次处理时间；Pi：周期时间
单处理机：$\sum_{i=1}^{m}\frac{Ci}{Pi}$≤1
多处理机：$\sum_{i=1}^{m}\frac{Ci}{Pi}$≤N（N：处理机数目）

## 最早截止时间优先算法（EDF）
**非抢占式**
用于非周期实时任务
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/2020aa26f36d89576b392d76194d9576_1740931278021.png)
**抢占式**
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/ace58dc9c386aea7fb54f74fe20c8acf_1740931278021.png)
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/7db8444c7e1deb7d1a70c76eb53f49b4_1740931278021.png)
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/da51ccafeb362351516205a91e233937_1740931285314.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/c854f6acfd47295e49df3e4c12fae082_1740931285314.png)


## 最低松弛度优先算法
低松弛=高紧急
紧急度越高，优先级越高
算法采用**抢占调度方式**
<font color="red">松弛度=必须完成时间-本身剩余运行时间-当前时间</font>

# 优先级倒置
优先级倒置现象：高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。
>例如：有三个完全独立的进程 Task A、Task B 和 Task C，Task A 的优 先级最高，Task B 次之，Task C 最低。Task A 和 Task C 共享同一个临 界资源 X。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/ead8c5d357f5c384c64d9fc8aebac911_1740931285314.png)
根据优先级原则，高优先级进程优先执行。但此例中 Task A 和 Task C共享同一个临界资源，出现了不合理的现象。
高优先级进程 Task A 因低优先进程 Task C 被阻塞，又因为低优先进程Task B的存在延长了被阻塞的时间。

解决方法：
1. Priority Ceiling
进程 Task C 在进入临界区后，Task C 所占用的处理机就不允许被抢占。 这种情况下，Task C 具有最高优先级（Priority Ceiling）。
如果系统中的临界区都较短且不多，该方法是可行的。反之，如果 Task C  临界区非常长，则高优先级进程 Task A 仍会等待很长的时间，其效果无法 令人满意。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/eff262195a5ec41b9d04a188602a8b7a_1740931285314.png)
2. Priority Inheritance
当高优先级进程 Task A 要进入临界区使用临界资源 X 时，如果已经有一个 低优先级进程 Task C 正在使用该资源，可以采用优先级继承（Priority  Inheritance）的方法。
此时一方面 Task A 被阻塞，另一方面由 Task C 继承 Task A 的优先级，并 一直保持到 Task C 退出临界区。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/846e4935cc3d64888ef743a0046778b5_1740931285314.png)

