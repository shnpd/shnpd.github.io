---
title: 【Go】GMP模型
toc: true
date: 2025-03-03 00:00:00
tags: 
  - go
categories: 
  - Golang



---

点击阅读更多查看文章内容<!--more-->

## 线程

一个线程需要在`内核态`与`用户态`之间进行切换，并且切换是受到操作系统控制的，可能这个现在需要等待多个时间片才能切换到内核态再调用操作系统底层的接口

> 那么我们是否可以用两个线程分别处理这两种状态呢？两个线程之间再`做好绑定`，当用户线程将任务提交给内核线程后，就可以不用`堵塞`了，可以去执行其他的任务了

<img src="https://camo.githubusercontent.com/61611ee3b365cc7304c483479361c3ded7fb719c04196fe2e8a7a6bd01c55428/68747470733a2f2f63646e2e66656e677869616e6875622e746f702f7265736f75726365732d6d61737465722f3230323330323233323334333535352e706e67" alt="image-20230223234355428" style="zoom:50%;" />

对于CPU来说（多核CPU），不需要关注线程切换的问题，只需要分配系统资源给`内核线程`进行调度即可，我们来给`用户线程`换个名字——`协程（co-runtine）`

如果是`一比一`的关系的话，上下文切换涉及用户态和内核态的切换，开销较大。

所以可以设计为`N 比 1`的形式，多个协程可以将任务一股脑的交给内核线程去完成，但是这样又有问题，如果其中一个问题在提交任务的过程中，堵塞住了，就会影响其他线程的工作，且无法利用多核CPU

<img src="https://camo.githubusercontent.com/c9d417dd88648e57e966fa46c70bb898fc6033d7fe436a0154bced6b606fd561/68747470733a2f2f63646e2e66656e677869616e6875622e746f702f7265736f75726365732d6d61737465722f3230323330323233323335303834302e706e67" alt="image-20230223235007732" style="zoom:50%;" />

所以一般为`M 比 N`的关系

<img src="https://camo.githubusercontent.com/7d035a80562631f6b63b2c360a82806621ca7867b06ce3a93bfd6d05cb41eba6/68747470733a2f2f63646e2e66656e677869616e6875622e746f702f7265736f75726365732d6d61737465722f3230323330323233323335353534312e706e67" alt="image-20230223235525408" style="zoom:50%;" />

---

## 早期的GMP

为了解决传统内核级的线程的创建、切换、销毁开销较大的问题，Go 语言将线程分为了两种类型：内核级线程 M （Machine），轻量级的用户态的协程 Goroutine，至此，Go 语言调度器的三个核心概念出现了两个：

**M**： Machine的缩写，代表了内核线程 OS Thread，CPU调度的基本单元；

**G**： Goroutine的缩写，用户态、轻量级的协程，一个 G 代表了对一段需要被执行的 Go 语言程序的封装；每个 Goroutine 都有自己独立的栈存放自己程序的运行状态；分配的栈大小 2KB，可以按需扩缩容；

<img src="https://pic3.zhimg.com/v2-723457d63ef16d7ac851427ae8f6367a_1440w.jpg" alt="img" style="zoom:50%;" />

在早期，Go 将传统线程拆分为了 M 和 G 之后，为了充分利用轻量级的 G 的低内存占用、低切换开销的优点，会在当前一个M上绑定多个 G，某个正在运行中的 G 执行完成后，Go 调度器会将该 G 切换走，将其他可以运行的 G 放入 M 上执行，这时一个 Go 程序中只有一个 M 线程：

<img src="https://pic4.zhimg.com/v2-5c3c22987861a8b3d1d5cb8df6d66a41_1440w.jpg" alt="img" style="zoom:50%;" />

这个方案的优点是用户态的 G 可以快速切换，不会陷入内核态，缺点是每个 Go 程序都用不了硬件的多核加速能力，并且 G 阻塞会导致跟 G 绑定的 M 阻塞，其他 G 也用不了 M 去执行自己的程序了。

为了解决这些不足，Go 后来快速上线了多线程调度器：

<img src="https://pic1.zhimg.com/v2-500982e44aeedfc05efb0690dfb5469c_1440w.jpg" alt="img" style="zoom:50%;" />

多个 M 对应多个 G

每个Go程序，都有多个 M 线程对应多个 G 协程，该方案有以下缺点：

1）**全局锁**、中心化状态带来的锁竞争导致的性能下降；在 GM 模型中，所有的 G 协程都存储在一个**全局队列**中，所有的 M 线程需要从全局队列中获取 G 来执行。； 2）M 会频繁交接 G，导致额外开销、性能下降；每个 M 都得能执行任意的 runnable 状态的 G； 3）每个 M 都需要处理内存缓存，导致大量的内存占用并影响数据局部性； 4）系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；

---

## 当前的GMP模型

为了解决多线程调度器的问题，Go 开发者 Dmitry Vyokov 在已有 G、M 的基础上，引入了 P 处理器，由此产生了当前 Go 中经典的 GMP 调度模型。

**P**：Processor的缩写，**代表一个虚拟的处理器，它维护一个局部的可运行的 G 队列，可以通过 CAS 的方式无锁访问，工作线程 M 优先使用自己的局部运行队列中的 G，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了大量 G 的并发性。每个 G 要想真正运行起来，首先需要被分配一个 P。**

如图 1.5 所示，是当前 Go 采用的 GMP 调度模型。可运行的 G 是通过处理器 P 和线程 M 绑定起来的，**M 的执行是由操作系统调度器将 M 分配到 CPU 上实现的**，**Go 运行时调度器负责调度 G 到 M 上执行，主要在用户态运行**，跟操作系统调度器在内核态运行相对应。

<img src="https://pic3.zhimg.com/v2-c407449388164e4d6d97b8e51c33bb28_1440w.jpg" alt="img" style="zoom:50%;" />

需要说明的是，Go 调度器也叫 Go 运行时调度器，或 **Goroutine 调度器，指的是由运行时在用户态提供的多个函数组成的一种机制，目的是为了高效地调度 G 到 M上去执行**。可以跟操作系统的调度器 OS Scheduler 对比来看，后者负责将 M 调度到 CPU 上运行。从操作系统层面来看，运行在用户态的 Go 程序只是一个请求和运行多个线程 M 的普通进程，操作系统不会直接跟上层的 G 打交道。

至于为什么不直接将本地队列放在 M 上、而是要放在 P 上呢？ 这是因为**当一个线程 M 阻塞（可能执行系统调用或 IO请求）的时候，可以将和它绑定的 P 上的 G 转移到其他线程 M 去执行**，如果直接把可运行 G 组成的本地队列绑定到 M，则万一当前 M 阻塞，它拥有的 G 就不能给到其他 M 去执行了。

**基于 GMP 模型的 Go 调度器的核心思想是：**

1. **尽可能复用线程 M**：避免频繁的线程创建和销毁；

2. **利用多核并行能力**：限制同时运行（不包含阻塞）的 M 线程数为 N，N 等于 CPU 的核心数目，这里通过设置 P 处理器的个数为 [GOMAXPROCS](https://zhida.zhihu.com/search?content_id=218409452&content_type=Article&match_order=1&q=GOMAXPROCS&zhida_source=entity) 来保证，GOMAXPROCS 一般为 CPU 核数，因为 M 和 P 是一一绑定的，没有找到 P 的 M 会放入空闲 M 列表，没有找到 M 的 P 也会放入空闲 P 列表；

3. **Work Stealing 任务窃取机制**：M 优先执行其所绑定的 P 的本地队列的 G，如果本地队列为空，可以从全局队列获取 G 运行，也可以从其他 M 偷取 G 来运行；为了提高并发执行的效率，M 可以从其他 M 绑定的 P 的运行队列偷取 G 执行，这种 GMP 调度模型也叫**任务窃取调度模型，**这里，任务就是指 G；

4. **Hand Off 交接机制**：M 阻塞，会将 M 上 P 的运行队列交给其他 M 执行，交接效率要高，才能提高 Go 程序整体的并发度；

5. **基于协作的抢占机制**：每个真正运行的G，如果不被打断，将会一直运行下去，为了保证公平，防止新创建的 G 一直获取不到 M 执行造成饥饿问题，Go 程序会保证每个 G 运行10ms 就要让出 M，交给其他 G 去执行；

6. **基于信号的真抢占机制**：尽管基于协作的抢占机制能够缓解长时间 GC 导致整个程序无法工作和大多数 Goroutine 饥饿问题，但是还是有部分情况下，Go调度器有无法被抢占的情况，例如，for 循环或者垃圾回收长时间占用线程，为了解决这些问题， Go1.14 引入了基于信号的抢占式调度机制，能够解决 GC 垃圾回收和栈扫描时存在的问题。