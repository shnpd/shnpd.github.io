---
title: 计算机网络笔记整理5——运输层
toc: true
date: 2022-01-03 18:49:44
tags: 网络 网络协议 udp
categories: 计算机网络
---

​​点击阅读更多查看文章内容<!--more-->

# [点此链接可跳转到：计算机网络笔记整理——目录索引页](https://blog.csdn.net/shn111/article/details/122298722)
> 参考书籍：《计算机网络》第八版 谢希仁编著

>@[toc]
# 运输层、UDP和TCP
## 运输层
- 负责主机中两个**进程**之间的通信
- 因特网的运输层 TCP、UDP
- 运输层的数据传送单元是报文段(TCP)或用户数据报(UDP)
- 运输层只存在于分组交换网外面的主机之中

运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层

只有位于网络边缘部分的主机的协议栈才有运输层，网络核心部分中的路由器在转发分组时都只用到下三层的功能。

通信的两端应当是两个主机中的进程。也就是说，端到端的通信是应用进程之间的通信

网络层为主机之间的通信提供服务，而运输层则在网络层的基础上，为应用程序之间的通信提供服务

>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信，这表面运输层有一个很重要的功能——复用和分用
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/bdddc1bd95faf410306f041677c0e342_1740930955310.png)

当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条**全双工的可靠信道**。但当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。
## 用户数据报协议UDP
UDP只在IP数据报服务之上增加了复用和分用的功能以及差错检测的功能
- UDP是无连接的
- UDP使用尽最大努力交付，即不保证可靠交付
- UDP是面向报文的，对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，一次交付一个完整的报文
- UDP没有拥塞控制，因此网络拥塞不会导致主机的发送速率降低，适合实时应用
- UDP支持一对一、一对多、多对一和多对多的交互通信
- UDP的首部开销小，只有8字节，TCP首部则有20字节

>**UDP是面向报文的**
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/4b3c989e1b696cf3f73f5f3a372214ed_1740930955310.png)

>应用程序必须选择合适大小的报文
>若报文太长：UDP把它交给IP层后，IP层需要分片，这会降低IP层的效率
>若报文太短，交给IP层后，会使IP数据报的首部相对太大，也会降低IP层的效率

>UDP的检验和是把首部和数据部分一起都检验

>例题
>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/b6fceb60427a0b1d2ad0430f596fbfc0_1740930955310.png)
>以太网的MTU为1500字节，将IP数据报封装到以太网帧中除去20字节的首部，一次最多只能传输1480字节
>UDP数据字段8192字节，首部字段8字节共8200字节
>8200/1480=5 8200%1480=800
>故应当划分为6个IP数据报片，前五个为数据字段长1480，最后一个数据字段长800
>片偏移以8字节为单位，1480/8=185，可得：0,185,370,555,740,925

## 传输控制协议TCP
- TCP是面向连接的运输层协议
- 每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的
- TCP提供可靠交付的服务
- TCP提供全双工通信
- 面向字节流。
  TCP中的“流”指的是流入或流出进程的字节序列。
  “面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流；
  TCP不保证接收方应用程序收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

>TCP连接是一条虚连接而不是一条真正的物理连接
>TCP对应用进程一次把多长的报文发送到TCP缓存中是不关心的
>TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP的报文长度是应用进程给出的)
>TCP可把太长的数据块划分短一些再传送
>TCP也可等待积累有足够多的字节后再构成报文段发送出去

**TCP的连接**：
每一条TCP连接有两个端点，TCP连接的端点叫做**套接字**或插口
端口号拼接到IP地址即构成了套接字
套接字socket=(IP地址：端口号)
每一条TCP连接唯一地被通信两端的两个端点所确定
TCP连接::={socket1，socket2}={(IP1:port1)，(IP2：port2)}

# TCP数据报

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/d7c14948ac2d18e3d22bb1a22c4f7d25_1740930955310.png)

- 源端口和目的端口：各占2字节，端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现
- 序号字段：TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值指的是本报文段发送的数据的第一个字节的序号
- 确认号字段：期望收到对方的下一个报文段的数据的第一个字节的序号(只有当ACK=1时确认号字段才有效)；若确认号=N，则表明：到序号N-1位置的所有数据都已正确收到
- 数据偏移：指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4字节为计算单位
- 保留字段：保留为今后使用，目前置为0
- 紧急URG：当URG=1时，表明紧急指针字段有效，应尽快传送(紧急指针字段，指出在本报文段中紧急数据共有多少个字节，紧急数据放在本报文端数据的最前面)
- 确认ACK：仅当ACK=1时确认号字段才有效，当ACK=0时，确认号无效。
- 推送PSH：接受TCP收到PSH=1的报文段内，就尽快地交付接受应用进程，而不再等到整个缓存都填满了后再向上交付
- 复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接
- 同步SYN：当SYN=1，ACK=0表示这是一个连接请求报文，对方若同意建立连接，则在相应的报文段中使用SYN=1和ACK=1。因此SYN=1就表示这是一个连接请求或连接接受报文。
- 终止FIN：用来释放一个连接，FIN=1表明此报文段是其发送的最后数据，并要求释放运输连接
- 窗口字段：用来让对方设置发送窗口的依据，单位为字节
- 检验和：检验范围包括首部和数据两部分，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部
- 选项字段：长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节，TCP最初只规定了一种选项，即最大报文段长度MSS，MSS是每一个TCP报文段中的数据字段的最大长度。
- 填充：为了使整个首部长度是4字节的整数倍

# TCP发送窗口机制

TCP的滑动窗口是以字节为单位的

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/2e34ab0be15e0601c29e21753d36ff82_1740930955310.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/9bfa9bad0301d06e1457ae691286543c_1740930963759.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/63f941a10b35127e0e793149c7bac5ae_1740930963759.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/43cf392be68768fd11e657338b29abeb_1740930963759.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/130f3d317744bea6eb5ed4294bcd2dc1_1740930963759.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/6a1d7bc9a7f072686a84a45a3ebb403b_1740930963759.png)
>发送缓存用来暂时存放：
发送应用程序传送给发送方TCP准备发送的数据
TCP已发送出但尚未收到确认的数据
>接受缓存用来暂时存放：
按序到达的、但尚未被接收应用程序读取的数据
不按序到达的数据

## 超时重传时间设置
TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是**报文段的往返时间RTT**。
TCP保留了RTT的一个**加权平均往返时间RTT~s~**(又称为平滑的往返时间),第一次测量RTT样本时，RTT~s~值就取为所测量到的RTT样本值。以后每测量到一个新的RTT样本，就按下式重新计算一次RTT~s~：
新的RTTs = (1-α) x (旧的RTTs) + α x (新的RTT样本)
注意：0 ≤ α < 1，若接近于零，表示RTT值更新较慢；若接近于1，表示RTT值更新较快。推荐取的α值为1/8，即0.125

**超时重传时间RTO**应略大于RTT~s~，建议使用下式计算：
RTO=RTT~s~+4×RTT~D~

**RTT~D~是RTT偏差的加权平均值**
第一次测量时，RTT~D~值取为RTT的一半，以后的测量中，使用下式计算
新的RTT~D~=(1 - β) × (旧的RTT~D~) + β × | RTT~S~ - 新的RTT样本 |
β是个小于1的系数，推荐值为1/4，即0.25

>![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/59ccbcbfe4629cecc9c524cc5b7805df_1740930972467.png)
γ的典型值是2
# TCP确认机制
选择确认SACK
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3a37cff77cadda8c38c209593c679519_1740930972467.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/39eaa40e119adea55a1c8206e915f59a_1740930972467.png)
>只能指明4个字节块是因为，4个字节快共有8个边界，每个边界用掉4个字节(因为序号有32位，需要使用4个字节表示),因而需要用32个字节，另外还需要两个字节，一个字节用来表明SACK选项，另一个字节指明这个选项要占用多少字节。
# TCP连接
运输连接有三个阶段：
- 连接建立
- 数据传送
- 连接释放

TCP连接的建立采用**客户服务器方式**
主动发起连接建立的应用进程叫做**客户**
被动等待连接建立的应用进程叫做**服务器**
## TCP的连接建立
TCP建立连接的过程叫做握手
握手需要在客户和服务器之间交换三个TCP报文。称之为三报文握手
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/e8718f1dbff90139115d7c52a0a2175c_1740930972467.png)
A向B传送的连接请求报文段中的seq = x，表明传送数据时的第一个数据字节的序号是x。
SYN=1的报文段不能携带数据，但要消耗掉一个序号
ACK报文段可以携带数据，如果不携带数据则不消耗序号
CLOSED——关闭状态
LISTEN——收听状态
SYN-SENT——同步已发送状态
SYN-RCVD——同步收到状态
ESTABLISHED——已建立连接状态

## TCP的连接释放
数据传输结束后，通信的双方都可以释放连接
TCP连接释放过程是四报文握手
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/0a65b2bad7f9e57d7c4b20acbb123f8f_1740930972467.png)
1. 第一个报文seq=u，它等于前面以传送过的数据的最后一个字节的序号加1，FIN报文段即使不携带数据，也消耗掉一个序号
2. B在收到第一个报文后即发出确认，seq=v，它等于B前面已传送过的数据的最后一个字节的序号加1.然后B就进入CLOSE-WAIT状态，此时A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A无数据发送，但B若发送数据，A仍要接受
3. 若B没有数据发送了，就通知TCP释放连接，此时seq=w(在半关闭状态，B可能又发送了一些数据)，重复上次的ack
4. A收到B的连接释放报文后，发出确认ack=w+1，seq=u+1(前面发送的FIN报文段要消耗掉一个序号)
5. A等待2MSL(最长报文段寿命)后才进入CLOSED状态，保证A发送的最后一个报文能够到达B。若这个报文丢失，A能在2MSL时间内收到重传的FIN+ACK报文，接着A重传确认，重启2MSL计时器；同时经过2MSL时间，可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

# TCP的拥塞控制
拥塞：某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。最坏结果：系统崩溃

TCP采用基于窗口的方法进行拥塞控制，这种方法属于闭环控制方法。

TCP发送方维持一个拥塞窗口CWND，大小取决于网络的拥塞程度，并且动态地变化，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况
真正的发送窗口值=Min(公告窗口值，拥塞窗口值)

## 拥塞的判断
- 重传定时器超时
- 收到三个相同(重复)的ACK

## TCP拥塞控制算法
### 慢开始
由小到大逐渐增大拥塞窗口数值
**初始拥塞窗口cwnd设置**为不超过2至4个SMSS(发送方的最大报文段)的数值
**慢开始门限ssthresh(状态变量)**：防止拥塞窗口cwnd增长过大引起网络拥塞
**拥塞窗口cwnd控制方法**：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值
拥塞窗口cwnd每次的增加量 = min(N,SMSS)
N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/abc34ac092a99e037fb7592f328faf1f_1740930981228.png)


**慢开始门限ssthresh的用法如下**：
当cwnd<ssthresh时，使用慢开始算法
当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法
当cwnd=ssthresh时，即可使用慢开始，也可使用拥塞避免
### 拥塞避免算法
让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。

>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(**重传定时器超时**)：
>1. ssthresh = max(cwnd/2,2)
>2. cwnd = 1
>3. 执行慢开始算法

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3f880efb476499b75aa7ab15c8ca12e3_1740930981228.png)


### 快重传算法
快重传FR(Fast Retransmission)算法可以让发送方尽早知道发生了个别报文段的丢失。
发送方只要**一连收到三个重复确认**,就知道接收方确实没有收到报文段，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/a194b8644e27026036c866d598c26ce2_1740930981228.png)


### 快恢复算法
当接收端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行**慢开始算法**，而是执行**快恢复算法**：
1. 慢开始门限ssthresh = 当前拥塞窗口 cwnd/2
2. 新拥塞窗口cwnd = 慢开始门限 ssthresh
3. 开始执行拥塞避免算法
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/797addee6ece9041c2ceb5640573091d_1740930981228.png)


