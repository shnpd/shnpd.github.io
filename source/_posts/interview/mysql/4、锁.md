---
title: 4、mysql锁
toc: true
date: 2025-03-03 00:00:00
tags: mysql
categories: 
	- 知识点整理
	- mysql
---

点击阅读更多查看文章内容<!--more-->

## 全局锁

要使用全局锁，则要执行这条命令：`flush tables with read lock`
**执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：**

对数据的增删改操作，比如 insert、delete、update等语句；
对表结构的更改操作，比如 alter table、drop table 等语句。
如果要释放全局锁，则要执行这条命令：`unlock tables`
当然，当会话断开了，全局锁会被自动释放。

全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

加上全局锁，意味着整个数据库都是只读状态，不能更新数据，这样会造成业务停滞。 既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？ 有的，如果数据库的引擎支持的事务支持**可重复读**的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。 因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。

---

## 表级锁

MySQL 里面表级别的锁有这几种： 

- 表锁； 
- 元数据锁（MDL）; 
- 意向锁； 
- AUTO-INC 锁；

### 表锁

先来说说表锁。

如果我们想对学生表（t_student）加表锁，可以使用下面的命令：

```mysql
//表级别的共享锁，也就是读锁；
//允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。
lock tables t_student read;

//表级别的独占锁，也就是写锁；
//允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。
lock tables t_stuent write;
```

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。

举个例子， 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句（t1加读锁，t2加写锁）则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。

---

### 元数据锁

再来说说元数据锁（MDL）。

我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。

反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，
4. 那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？这是因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

---

### 意向锁
接着，说说意向锁。

- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
- 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：

``` mysql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。**

**表锁和行锁**是满足读读共享、读写互斥、写写互斥的。

如果没有「意向锁」，那么加**「独占表锁」**时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。**那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。**

**所以，意向锁的目的是为了快速判断表里是否有记录被加锁**

---

### AUTO-INC 锁

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。

在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，**等插入语句执行完成后，才会把 AUTO-INC 锁释放掉**。

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。

但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后**给该字段赋值一个自增的值，就把这个轻量级锁释放了**，而不需要等待整个插入语句执行完后才释放锁。

---

## 行级锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。

加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁。

前面也提到，**普通的 select 语句是不会对记录加锁的，因为它属于快照读**。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。

```mysql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```

上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。

共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png)

行级锁的类型主要有三类： 

- Record Lock，记录锁，也就是仅仅把一条记录锁上； 
- Gap Lock，间隙锁，锁定一个范围，而不是具体的行。
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身

---

### Record Lock

Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的： 

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）; 
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

---

### Gap Lock

间隙锁锁定的是一个索引区间，而不是具体的行。这意味着即使在这个区间内没有实际的数据行存在，这个区间仍然会被锁定。这可以阻止其他事务在这个区间内**插入**新的数据行。

假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png)

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的**，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，**因为间隙锁的目的是防止插入幻影记录而提出的**。

---

### Next-Key Lock 

> 通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。 

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png)

所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。 

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被**阻塞**的。 比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。 虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的

---

### 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png)

当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，**这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态**（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。

插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。

如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

---

## update 没加索引会锁全表？

InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。

因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。

**当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的**，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。

在 InnoDB 事务中，**对记录加锁带基本单位是 next-key 锁**，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。

比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。

这里举个例子，这里有一张数据库表，其中 id 为主键索引。

![img](https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png)

假设有两个事务的执行顺序如下：

![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/d2326f98cbb34fc09ca4013703251501.png)

可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id = 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。 

但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。 假设有两个事务的执行顺序如下：

<img src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt="img" style="zoom:67%;" />

可以看到，这次事务 B 的 update 语句被阻塞了。 这是因为事务 A的 update 语句中 where 条件没有索引列，触**发了全表扫描，在扫描过程中会对索引加锁**，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表

![img](https://cdn.xiaolincoding.com//mysql/other/63e055617720853f5b64c99576227c09.png)

因此，当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 select ... from语句，其他语句都会被锁住不能执行，业务会因此停滞。

 那 update 语句的 where 带上索引就能避免全表记录加锁了吗？ 并不是。

关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。

**如何避免这种事故的发生？**

我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。

大致的意思是，当 sql_safe_updates 设置为 1 时。

update 语句必须满足如下条件之一才能执行成功：

- 使用 where，并且 where 条件中必须有索引列；
- 使用 limit；
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；

delete 语句必须满足以下条件能执行成功：

- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；

如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。

---

## MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？

### 实验验证

实验环境：MySQL 8.0 版本，可重复读隔离级。 

现在有一张用户表（t_user），表里只有一个主键索引，表里有以下行数据：

<img src="https://cdn.xiaolincoding.com//mysql/other/75c5c503d7df4ad091bfc35708dce6c4.png" alt="在这里插入图片描述" style="zoom:67%;" />

现在有一个 A 事务执行了一条查询语句，查询到年龄大于 20 岁的用户共有 6 条行记录。

<img src="https://cdn.xiaolincoding.com//mysql/other/68dd89fc95aa42cf9b0c4251d4e9226c.png" alt="img" style="zoom:67%;" />

然后， B 事务执行了一条删除 id = 2 的语句：

<img src="https://cdn.xiaolincoding.com//mysql/other/2332fad58bc548ec917ba7ea44d09d30.png" alt="img" style="zoom: 67%;" />

此时，B 事务的删除语句就陷入了等待状态，说明是无法进行删除的。 

**因此，MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读问题。**

---

### 加锁分析

问题来了，A 事务在执行 select ... for update 语句时，具体加了什么锁呢？ 

我们可以通过 select * from performance_schema.data_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。 输出的内容很多，共有 11 行信息，我删减了一些不重要的信息：

<img src="https://cdn.xiaolincoding.com//mysql/other/90e68bf52b2c4e8a9127cfcbb0f0a322.png" alt="请添加图片描述" style="zoom:67%;" />



从上面输出的信息可以看到，共加了两种不同粒度的锁，分别是：

- 表锁（LOCK_TYPE: TABLE）：X 类型的意向锁；
- 行锁（LOCK_TYPE: RECORD）：X 类型的 next-key 锁；

这里我们重点关注「行锁」，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思：

- 如果 LOCK_MODE 为 X，说明是 next-key 锁；
- 如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；
- 如果 LOCK_MODE 为 X, GAP，说明是间隙锁；

然后通过 LOCK_DATA 信息，可以确认 next-key 锁的范围，具体怎么确定呢？

根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，而锁范围的最左值为 LOCK_DATA 的上一条记录的值。

因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了 10 个 next-key 锁，如下：

- X 型的 next-key 锁，范围：(-∞, 1]
- X 型的 next-key 锁，范围：(1, 2]
- X 型的 next-key 锁，范围：(2, 3]
- X 型的 next-key 锁，范围：(3, 4]
- X 型的 next-key 锁，范围：(4, 5]
- X 型的 next-key 锁，范围：(5, 6]
- X 型的 next-key 锁，范围：(6, 7]
- X 型的 next-key 锁，范围：(7, 8]
- X 型的 next-key 锁，范围：(8, 9]
- X 型的 next-key 锁，范围：(9, +∞]

**这相当于把整个表给锁住了，其他事务在对该表进行增、删、改操作的时候都会被阻塞。**

只有在事务 A 提交了事务，事务 A 执行过程中产生的锁才会被释放。

> **为什么只是查询年龄 20 岁以上行记录，而把整个表给锁住了呢？**

这是因为事务 A 的这条查询语句是全表扫描，**锁是在遍历索引的时候加上的，并不是针对输出的结果加锁**。  

<img src="https://cdn.xiaolincoding.com//mysql/other/e0b2a18daa864306a84ec51c0866d170.png" alt="img" style="zoom:67%;" />

因此，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。

> **如果对 age 建立索引，事务 A 这条查询会加什么锁呢？**

接下来，我对 age 字段建立索引，然后再执行这条查询语句：

<img src="https://cdn.xiaolincoding.com//mysql/other/68dd89fc95aa42cf9b0c4251d4e9226c-20230309222654910.png" alt="img" style="zoom:67%;" />

接下来，继续通过 select * from performance_schema.data_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。 具体的信息，我就不打印了，我直接说结论吧。 

因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。 主键索引会加如下的锁： 

- X 型的记录锁，锁住 id = 2 的记录； 
- X 型的记录锁，锁住 id = 3 的记录； 
- X 型的记录锁，锁住 id = 5 的记录； 
- X 型的记录锁，锁住 id = 6 的记录； 
- X 型的记录锁，锁住 id = 7 的记录； 
- X 型的记录锁，锁住 id = 8 的记录； 

分析 age 索引加锁的范围时，要先对 age 字段进行排序。

<img src="https://cdn.xiaolincoding.com//mysql/other/b93b31af4eec416e9f00c2adc1f7d0c1.png" alt="请添加图片描述" style="zoom: 50%;" />

age 索引加的锁：

- X 型的 next-key lock，锁住 age 范围 (19, 21] 的记录；
- X 型的 next-key lock，锁住 age 范围 (21, 21] 的记录；
- X 型的 next-key lock，锁住 age 范围 (21, 23] 的记录；
- X 型的 next-key lock，锁住 age 范围 (23, 23] 的记录；
- X 型的 next-key lock，锁住 age 范围 (23, 39] 的记录；
- X 型的 next-key lock，锁住 age 范围 (39, 43] 的记录；
- X 型的 next-key lock，锁住 age 范围 (43, +∞] 的记录；

化简一下，age 索引 next-key 锁的范围是 (19, +∞]。

可以看到，对 age 字段建立了索引后，查询语句是索引查询，并不会全表扫描，因此不会把整张表给锁住。

---

## 死锁

### 死锁的发生

本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。 接下来，我用实战的方式来带大家看看死锁是怎么发生的。 我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：

然后，先 t_order 表里现在已经有了 6 条记录：假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：

<img src="https://cdn.xiaolincoding.com//mysql/other/90c1e01d0345de639e3426cea0390e80.png" alt="img" style="zoom:67%;" />

可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。 这里在查询记录是否存在的时候，使用了 select ... for update 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。

事务 A 在执行下面这条语句的时候： select id from t_order where order_no = 1007 for update; 我们可以通过 select * from performance_schema.data_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。

<img src="https://cdn.xiaolincoding.com//mysql/other/1cf8614eba3b45b9874dc6204b4d0cd1.png" alt="img" style="zoom:50%;" />

从上图可以看到，共加了两个锁，分别是： 表锁：X 类型的意向锁； 行锁：X 类型的间隙锁； 

这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁： 

- 如果 LOCK_MODE 为 X，说明是 X 型的 next-key 锁； 
- 如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是 X 型的记录锁； 
- 如果 LOCK_MODE 为 X, GAP，说明是 X 型的间隙锁； 

因此，此时事务 A 在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是(1006, +∞]。 next-key 锁的范围 (1006, +∞]，是怎么确定的？ 根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。

**当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住**： `Insert into t_order (order_no, create_date) values (1008, now());` 因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，而**插入意向锁与间隙锁是冲突的**，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。

而**间隙锁与间隙锁之间是兼容的，所以所以两个事务中 `select ... for update `语句并不会相互影响**。 案例中的事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为(1006,+∞]的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

---

### 如何避免死锁？

死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：

- 设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。
- 开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。

上面这个两种策略是「当有死锁发生时」的避免方式。

我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。

---

### 死锁问题分析

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="img" style="zoom:67%;" />

先创建一张 t_student 表，假设除了 id 字段，其他字段都是普通字段。然后，插入相关的数据后，t_student 表中的记录如下：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/t_student.png" alt="img" style="zoom:67%;" />

启动两个事务，按照题目的 SQL 执行顺序，过程如下表格：  

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/ab%E4%BA%8B%E5%8A%A1%E6%AD%BB%E9%94%81.drawio.png" alt="img" style="zoom:67%;" />

可以看到，事务 A 和 事务 B 都在执行 insert 语句后，都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。

我们可以通过 `select * from performance_schema.data_locks\G;` 这条语句，查看事务执行 SQL 过程中加了什么锁。 接下来，针对每一条 SQL 语句分析具体加了什么锁。 

- Time 1 阶段，事务 A 执行以下语句：

  ```mysql
  # 事务 A
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> update t_student set score = 100 where id = 25;
  Query OK, 0 rows affected (0.01 sec)
  Rows matched: 0  Changed: 0  Warnings: 0
  ```

  然后执行 `select * from performance_schema.data_locks\G;` 这条语句，查看事务 A 此时加了什么锁。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%BA%8B%E5%8A%A1a%E7%9A%84%E9%94%81.png" alt="img" style="zoom:50%;" />

从上图可以看到，共加了两个锁，分别是： 表锁：X 类型的意向锁； 行锁：X 类型的间隙锁；
此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加的是间隙锁，锁范围是(20, 30)。(因为id=25的数据不存在数据库在检索索引的时候只需要按顺序检索20,30就可以确定25不存在，所以检索的索引范围就是(20,30))

- Time 2 阶段，事务 B 执行以下语句：

  ```mysql
  # 事务 B
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> update t_student set score = 100 where id = 26;
  Query OK, 0 rows affected (0.01 sec)
  Rows matched: 0  Changed: 0  Warnings: 0
  ```

  然后执行 select * from performance_schema.data_locks\G; 这条语句，查看事务 B 此时加了什么锁。

  <img src="https://cdn.xiaolincoding.com//mysql/other/44277cfefbd6446db861bfb81a1e4a59.png" alt="在这里插入图片描述" style="zoom:50%;" />

  从上图可以看到，行锁是 X 类型的间隙锁，间隙锁的范围是(20, 30)。

- Time 3，事务 A 插入了一条记录：

  ```mysql
  # Time 3 阶段，事务 A 插入了一条记录
  mysql> insert into t_student(id, no, name, age,score) value (25, 'S0025', 'sony', 28, 90);
      /// 阻塞等待......
  ```

  此时，事务 A 就陷入了等待状态。 

  然后执行 select * from performance_schema.data_locks\G; 这条语句，查看事务 A 在获取什么锁而导致被阻塞。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%BA%8B%E5%8A%A1a%E7%AD%89%E5%BE%85%E4%B8%AD.png" alt="img" style="zoom:50%;" />

  可以看到，事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 (20, 30)）中插入了一条记录，所以事务 A 的插入操作生成了一个**插入意向锁**（LOCK_MODE:INSERT_INTENTION）。

  插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁。插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作。 如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。 插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的。

- Time 4，事务 B 插入了一条记录：

  ```mysql
  # Time 4 阶段，事务 B 插入了一条记录
  mysql> insert into t_student(id, no, name, age,score) value (26, 'S0026', 'ace', 28, 90);
      /// 阻塞等待......
  ```

  此时，事务 B 就陷入了等待状态。 

  然后执行 select * from performance_schema.data_locks\G; 这条语句，查看事务 B 在获取什么锁而导致被阻塞。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%BA%8B%E5%8A%A1b%E7%AD%89%E5%BE%85%E4%B8%AD.png" alt="img" style="zoom:50%;" />

  可以看到，事务 B 在生成插入意向锁时而导致被阻塞，这是因为事务 B 向事务 A 生成的范围为 (20, 30) 的间隙锁插入了一条记录，而插入意向锁和间隙锁是冲突的，所以事务 B 在获取插入意向锁时就陷入了等待状态。
