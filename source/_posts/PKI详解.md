---
title: PKI详解
toc: true
date: 2022-05-08 18:34:36
tags: https ssl 安全
categories: 杂项
---

​​点击阅读更多查看文章内容<!--more-->

# 应用场景
公钥密码算法一般包括加解密、数字签名两种使用模型，在加解密模型中，Alice想要和Bob通信，需要用Bob的公钥对明文进行加密。这里就存在一个问题，如何判断某个公钥是Bob的公钥呢？如果存在攻击者自行生成公私钥对并谎称是Bob的公钥，那么攻击者就可以窃听到属于Alice和Bob的秘密信息，Bob反而不能解密这些信息。
# PKI概念
PKI（Public Key Infrastructure）通过数字证书，可以很好的解决上述的公钥归属问题，PKI中文译为公钥基础设施，是基于公钥密码学建立起的一种普遍使用的基础设施，其主要功能是绑定证书持有者的身份和相关的密钥对（通过为公钥及相关的用户身份信息签发数字证书），为用户提供方便的证书申请、证书作废、证书获取、证书状态查询的途径，并利用数字证书及相关的各种服务（证书发布，黑名单发布，时间戳服务等）实现通信中各实体的身份认证、完整性、抗抵赖性和保密性。
# PKI基本组件
- 公钥证书：包含了用于签名和加密数据的公钥的电子凭证，是PKI的核心元素
- 证书颁发机构（CA）：数字证书的申请及签发机关，CA必须具备权威性
- 注册机构（RA）：CA的前端代理，减轻CA的负担，主要完成接收证书请求，验证请求着的身份
- 证书资料库（Reposity）：存储已签发的数字证书和公钥，以及相关证书目录，用户可由此获得所需的其他用户的证书及公钥
- 证书吊销列表（CRL）：在有效期内吊销的证书列表，在线证书状态协议OCSP是获得证书状态的国际协议
- 署名用户（Subscriber）：作为主体署名证书并依据策略使用证书和相应密钥的实体
- 依赖方（Relying party）：一个接收包括证书和签名信息的人或者机构，利用证书提供的公钥验证其有效性，与持证人建立保密通信，接收处于依赖的地位
# 数字证书
数字证书是PKI最基本的元素，其回答了“公钥属于谁”的问题，证书中最基本的内容是证书持有者的身份信息和公钥数据，以及用于验证证书完整性的CA签名结果。X.509证书是通用的PKI数字证书格式，如下图所示：
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/e402a12ff0958e7fee4bf5ee5e292068_1740930584194.png)


一张X.509数字证书由证书内容、签名算法和签名结果组成。需要使用他人证书的用户依照签名算法，用CA的公钥验证签名结果，从而保证证书的完整性，安全地获取公钥。
-	版本号：证书格式可能会不断改进，版本号给出了证书遵从的格式。
-	证书主体：证书的持有者
-	主体公钥信息：指明所用的公钥算法和公钥信息本身
-	签发者：签发该证书的CA
-	序列号：每个CA用来唯一标识其所签发的证书，也就是说，对于某一个CA而言，其签发的每一张证书的序列号必须互不相同。“签发者”+“序列号”可以唯一地标识一张数字证书
-	有效期：包括开始日期和结束日期，只有在有效期内的证书才是有效的
-	证书扩展：满足实际应用中的更多需求，证书可能携带的更多信息，证书扩展和上述内容一起被CA签名

[参考链接](https://zhuanlan.zhihu.com/p/373863242)
# CA证书认证流程

>下面是我在查资料的时候找到的两种流程一个是侧重于证书内容的一个是侧重于通信流程的，大家可以都看一看加深理解
>[证书内容参考链接](https://blog.csdn.net/weixin_44811851/article/details/121995190)
[通信流程参考链接](https://blog.csdn.net/lk2684753/article/details/100160856)
### 证书内容
>以下流程实现server申请证书，并将得到的证书发送给client，使client得到可信的server的公钥
 
 ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/3fb51f2dd638df45ad3d7e453129e3e5_1740930584194.png)

**1.	申请认证（证书）**
-	服务端S向第三方权威机构CA申请证书，服务器S先生成公私钥对
-	确认信息里面绑定我们当前使用哪个域名，以及申请者以及公钥
-	生成请求文件.csr（csr是我们服务端S向CA提交申请的文件）***注意：提交信息里不包含私钥***

**2.	审核信息**
-	CA收到服务端S发送的信息先去审核（CA通过线上、线下等多种手段验证申请者提供信息的真实性）
-	审核通过，CA会向申请者签发认证文件-证书

**3.	签发证书**
-	签名证书里的明文信息通过哈希算法加密生成摘要1
-	CA机构用自己的私钥对摘要1进行加密，得到其对应的签名
-	签名+明文信息组成了证书，把这个证书发给服务端S

**4. 返回证书**
- 服务端S把CA证书发送给客户端C

**5. 验证证书**
- 客户端会内置信任CA的证书信息（包含公钥），如果CA不被信任，则找不到对应CA的证书，证书会被判定为非法
- 客户端C利用对应CA的公钥解密签名数据，拿到了摘要1
- 客户端C读取证书中的相关的明文信息，采用哈希算法加密得到信息摘要2
- 对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法
- 提取出公钥pub_server，至此就认可了服务端S，拿到了服务端的公钥


### 详细通信过程
>下图展示了Alice向Bob发送密文的场景，在生成密文时所使用的Bob的公钥是通过认证机构获取的。
认证机构必须是可信的，对于“可信的第三方”，下图中会使用Trent这个名字，这个词是从trust（信任）一词演变而来的。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/shnpd/blog-pic@main/csdn/5523afe9e2b237f4de006d1ad12cc589_1740930584194.png)

**1.	Bob生成密钥对**
- 要使用公钥密码进行通信，首先需要生成密钥对。Bob生成了一对公钥和私钥，并将私钥自行妥善保管。在这里，密钥对是由Bob自己生成的，也可以由认证机构代为生成。

**2.	Bob在认证机构Trent注册自己的公钥**
- 在这里Bob则将公钥发送给了认证机构Trent，这是因为Bob需要请认证机构Trent对他的公钥加上数字签名（也就是生成证书）。
- Trent收到Bob的公钥后，会确认所收到的公钥是否为Bob本人所有（通过线上+线下的方式）

**3. 认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书**
- Trent对Bob的公钥加上数字签名。为了生成数字签名，需要Trent自身的私钥，因此Trent需要事先生成好密钥对。

**4. Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书）**
- 现在Alice需要向Bob发送密文，因此她从Trent处获取证书。证书中包含了Bob的公钥。

**5. Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性**
- Alice使用认证机构Trent的公钥对证书中的数字签名进行验证。如果验证成功，就相当于确认了证书中所包含的公钥的确是属于Bob的。到这里，Alice就得到了合法的Bob的公钥。

**6.Alice用Bob的公钥加密消息并发送给Bob**
- Alice用Bob的公钥加密要发送的消息，并将消息发送给Bob。

**7.Bob用自己的私钥解密密文得到Alice的消息**
 - Bob收到Alice发送的密文，然后用自己的私钥解密，这样就能够看到Alice的消息了。

上面就是利用认证机构Trent进行公钥密码通信的流程。其中1、2、3这几个步骤仅在注册新公钥时才会进行，并不是每次通信都需要。此外，步骤 4 仅在Alice第一次用公钥密码向Bob发送消息时才需要进行，只要Alice将Bob的公钥保存在电脑中，在以后的通信中就可以直接使用了。


